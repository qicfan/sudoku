////  sudoku.c//  sudoku////  Created by 齐 晓鹏 on 12-3-25.//  Copyright (c) 2012年 Yushuo. All rights reserved.//#include <stdio.h>#include <stdlib.h>#include <time.h>#include <string.h>// 数独的解int SUDOKU[9][9];// 挖好坑要显示的数独int DIS_SUDOKU[9][9];// 定义一个简单的树typedef struct tree_struct {	// 该节点的值	int data;	// 子节点的数量	int child_count;	// 该节点的x轴	int x;	// 该节点的y轴	int y;	// 该节点在父级子节点中的位置	int position;	// 该节点的父节点	struct tree_struct *parent;	// 该节点的子节点数组	struct tree_struct *childs[9];} tree_node;/** 生成1-9的随机数 */int randoms() {	int r;	r = rand() % 9;	if (r == 0) {		return 1;	}	return r;}tree_node * create_node(int data, int x, int y) {	int i;	tree_node * new_node = (tree_node *)malloc(sizeof(tree_node));	if (new_node == NULL) {		printf("malloc failed\n");		exit(0);	}	new_node->data = data;	new_node->x = x;	new_node->y = y;	new_node->child_count = 0;	for (i=0; i<9; i++) {		new_node->childs[i] = NULL;	}	new_node->parent = NULL;	new_node->position = 0;	return new_node;}void append_child(tree_node *node, tree_node *child) {	node->childs[node->child_count] = child;	child->position = node->child_count;	node->child_count ++;	child->parent = node;	return;}int delete_node(tree_node *node) {	if (node == NULL) {		return 1;	}	if (node->child_count > 0) {		// 如果还有子节点则不能删除		int j;		for (j=0;j<node->child_count;j++) {			delete_node(node->childs[j]);		}	}	if (node->parent != NULL) {		tree_node *tmp;		int end = node->parent->child_count - 1;		// 与最后一位调换位置		if (node->position == end || node->parent->child_count == 1) {			node->parent->childs[node->position] = NULL;		} else {			tmp = node->parent->childs[end];			tmp->position = node->position;			node->parent->childs[end] = NULL;			node->parent->childs[node->position] = tmp;		}		node->parent->child_count --;	}	free(node);	node = NULL;	return 0;}void print_sudoku() {	int x, y;	for (y=0; y<9; y++) {		printf("| ");		for (x=0; x<9; x++) {			printf("%d | ", SUDOKU[y][x]);		}		printf("\n");	}	printf("\n");	return;}int validate_pit(int x, int y, int z) {	int i,j;	// 判断当前行是否有重复值	for (j=0; j<9; j++) {		if (SUDOKU[y][j] == z) {			// 有重复值，返回0			return 0;		}	}	// 判断当前列是否有重复值	for (j=0; j<9; j++) {		if (SUDOKU[j][x] == z) {			return 0;		}	}	// 判断九宫格是否有重复值	int xmin = (int)x/3 * 3;	int ymin = (int)y/3 * 3;	int xmax = xmin + 2;	int ymax = ymin + 2;	for (i=ymin; i<=ymax; i++) {		for (j=xmin; j<= xmax; j++) {			if (SUDOKU[i][j] == z) {				return 0;			}		}	}	return 1;}void create_pit(int x, int y) {	int z;	z = randoms();	if (validate_pit(x,y,z) == 1) {		SUDOKU[y][x] = z;		return;	}	return create_pit(x, y);}void create_random_pit() {	int x,y;	srand((int)time(0));	// 给1-9行随机位置赋予种子	// 种子随机给予	for (y=0; y<9; y++) {		x = randoms();		create_pit(x, y);	}	return;}void get_better(tree_node *current_node, int x, int y) {	// 定义一个数组	tree_node *node;	int better[9];	int i,j;	for (i=0;i<9;i++) {		better[i] = i + 1;	}	// 判断当前行是否有重复值	for (j=0; j<9; j++) {		if (SUDOKU[y][j] > 0) {			better[SUDOKU[y][j]-1] = 0;		}	}	// 判断当前列是否有重复值	for (j=0; j<9; j++) {		if (SUDOKU[j][x] > 0) {			better[SUDOKU[j][x]-1] = 0;		}	}	// 判断九宫格是否有重复值	int xmin = (int)x/3 * 3;	int ymin = (int)y/3 * 3;	int xmax = xmin + 2;	int ymax = ymin + 2;	for (i=ymin; i<=ymax; i++) {		for (j=xmin; j<= xmax; j++) {			if (SUDOKU[i][j]  > 0) {				better[SUDOKU[i][j]-1] = 0;			}		}	}	// 重新整理better	j = 0;	for (i=0; i<9; i++) {		if (better[i] == 0) {			continue;		}		node = create_node(better[i], x, y);		append_child(current_node, node);	}	return;}int fill_pit() {	int x, y, z, c=0;	tree_node *current_node;	tree_node *parent_node = create_node(0, -1, -1);	for (y=0; y<9; y++) {		for (x=0; x<9; x++) {			if (SUDOKU[y][x] > 0) {				continue;			}			// 如果父节点没有子节点，则首先建立子节点模型			if (parent_node->child_count == 0) {				get_better(parent_node, x, y);				c = 0;			}			for (z=0; z<parent_node->child_count; z++) {				current_node = parent_node->childs[z];				if (!validate_pit(current_node->x, current_node->y, current_node->data)) {					// 这个解不适用					// 删除这个节点					delete_node(current_node);					continue;				} else {					SUDOKU[current_node->y][current_node->x] = current_node->data;					parent_node = current_node;					current_node = NULL;					c = 1;					break;				}			}			// 如果一个解也么有，则回溯			if (c == 0) {				while (1) {					// 删除当前的父节点					current_node = parent_node;					SUDOKU[current_node->y][current_node->x] = 0;					parent_node = current_node->parent;					delete_node(current_node);					x = parent_node->x;					y = parent_node->y;					if (parent_node->x == -1 && parent_node->child_count == 0) {						// 如果确实无解，则返回1						return 1;					}					if (parent_node->child_count > 0) {						// 碰到依然有解的节点，则跳出循环						break;					}				}			}		}	}	delete_node(current_node);	delete_node(parent_node);	return 0;}void hash_sudoku(level) {	return;}void init_sudoku() {	int x,y;	for (y=0; y<9; y++) {		for (x=0; x<9; x++) {			SUDOKU[y][x] = 0;		}	}	return;}void lgenerate_sudoku(int level) {	// 初始化数独种子（给每一行随机生成一个数字）	init_sudoku();	create_random_pit();	// 循环给每一个格子填充数字（求解）	fill_pit();	// 给数独挖坑	hash_sudoku(level);	return;}