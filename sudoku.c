////  sudoku.c//  sudoku////  Created by 齐 晓鹏 on 12-3-25.//  Copyright (c) 2012年 Yushuo. All rights reserved.//#include <stdio.h>#include <stdlib.h>#include <time.h>#include "common.h"#include "sudoku.h"void print_sudoku() {	int x, y;	for (y=0; y<9; y++) {		printf("| ");		for (x=0; x<9; x++) {			printf("%d | ", SUDOKU[y][x]);		}		printf("\n");	}	printf("\n");	return;}int validate_pit(int x, int y, int z) {	int i,j;	// 判断当前行是否有重复值	for (j=0; j<9; j++) {		if (SUDOKU[y][j] == z) {			// 有重复值，返回0			return 0;		}	}	// 判断当前列是否有重复值	for (j=0; j<9; j++) {		if (SUDOKU[j][x] == z) {			return 0;		}	}	// 判断九宫格是否有重复值	int xmin = (int)x/3 * 3;	int ymin = (int)y/3 * 3;	int xmax = xmin + 2;	int ymax = ymin + 2;	for (i=ymin; i<=ymax; i++) {		for (j=xmin; j<= xmax; j++) {			if (SUDOKU[i][j] == z) {				return 0;			}		}	}	return 1;}void create_pit(int x, int y) {	int z;	z = randoms();	if (validate_pit(x,y,z) == 1) {		SUDOKU[y][x] = z;		return;	}	return create_pit(x, y);}void create_random_pit() {	int x,y;	srand((int)time(0));	// 给1-9行随机位置赋予种子	// 种子随机给予	for (y=0; y<9; y++) {		x = randoms();		create_pit(x, y);	}	return;}void get_better(tree_node *current_node, int x, int y) {	// 定义一个数组	tree_node *node;	int better[9];	int i,j;	for (i=0;i<9;i++) {		better[i] = i + 1;	}	// 判断当前行是否有重复值	for (j=0; j<9; j++) {		if (SUDOKU[y][j] > 0) {			better[SUDOKU[y][j]-1] = 0;		}	}	// 判断当前列是否有重复值	for (j=0; j<9; j++) {		if (SUDOKU[j][x] > 0) {			better[SUDOKU[j][x]-1] = 0;		}	}	// 判断九宫格是否有重复值	int xmin = (int)x/3 * 3;	int ymin = (int)y/3 * 3;	int xmax = xmin + 2;	int ymax = ymin + 2;	for (i=ymin; i<=ymax; i++) {		for (j=xmin; j<= xmax; j++) {			if (SUDOKU[i][j]  > 0) {				better[SUDOKU[i][j]-1] = 0;			}		}	}	// 重新整理better	j = 0;	for (i=0; i<9; i++) {		if (better[i] == 0) {			continue;		}		node = create_node(better[i], x, y);		append_child(current_node, node);	}	return;}int fill_pit() {	int x, y, z, c=0;	tree_node *current_node;	tree_node *parent_node = create_node(0, -1, -1);	for (y=0; y<9; y++) {		for (x=0; x<9; x++) {			if (SUDOKU[y][x] > 0) {				continue;			}			// 如果父节点没有子节点，则首先建立子节点模型			if (parent_node->child_count == 0) {				get_better(parent_node, x, y);				c = 0;			}			for (z=0; z<parent_node->child_count; z++) {				current_node = parent_node->childs[z];				if (!validate_pit(current_node->x, current_node->y, current_node->data)) {					// 这个解不适用					// 删除这个节点					delete_node(current_node);					continue;				} else {					SUDOKU[current_node->y][current_node->x] = current_node->data;					parent_node = current_node;					current_node = NULL;					c = 1;					break;				}			}			// 如果一个解也么有，则回溯			if (c == 0) {				while (1) {					// 删除当前的父节点					current_node = parent_node;					SUDOKU[current_node->y][current_node->x] = 0;					parent_node = current_node->parent;					delete_node(current_node);					x = parent_node->x;					y = parent_node->y;					if (parent_node->x == -1 && parent_node->child_count == 0) {						// 如果确实无解，则返回1						return 1;					}					if (parent_node->child_count > 0) {						// 碰到依然有解的节点，则跳出循环						break;					}				}			}		}	}	delete_node(current_node);	delete_node(parent_node);	return 0;}void hash_sudoku(level) {	return;}void init_sudoku() {	int x,y;	for (y=0; y<9; y++) {		for (x=0; x<9; x++) {			SUDOKU[y][x] = 0;		}	}	return;}void generate_sudoku(int level) {	// 初始化数独种子（给每一行随机生成一个数字）	init_sudoku();	create_random_pit();	// 循环给每一个格子填充数字（求解）	fill_pit();	// 给数独挖坑	hash_sudoku(level);	return;}int main() {	generate_sudoku(1);	print_sudoku();	return 0;}